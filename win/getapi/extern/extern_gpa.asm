; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	c:\hub\shellcode\win\getapi\extern\extern_gpa.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BG@NJBDAAND@?6GetProcAddress?5?3?5?$CFp?6?$AA@ ; `string'
PUBLIC	??_C@_0N@INAGJMNN@advapi32?4dll?$AA@		; `string'
PUBLIC	_main
EXTRN	_printf:PROC
EXTRN	__imp__LoadLibraryA@4:PROC
;	COMDAT ??_C@_0BG@NJBDAAND@?6GetProcAddress?5?3?5?$CFp?6?$AA@
; File c:\hub\shellcode\win\getapi\extern\extern_gpa.c
CONST	SEGMENT
??_C@_0BG@NJBDAAND@?6GetProcAddress?5?3?5?$CFp?6?$AA@ DB 0aH, 'GetProcAdd'
	DB	'ress : %p', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@INAGJMNN@advapi32?4dll?$AA@
CONST	SEGMENT
??_C@_0N@INAGJMNN@advapi32?4dll?$AA@ DB 'advapi32.dll', 00H ; `string'
; Function compile flags: /Ogspy
CONST	ENDS
;	COMDAT _main
_TEXT	SEGMENT
_gpa$ = -8						; size = 4
_ft$ = -4						; size = 4
_i$ = -4						; size = 4
_main	PROC						; COMDAT

; 35   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ecx
	push	edi

; 36   :   DWORD                    rva, hash, i;
; 37   :   PIMAGE_IMPORT_DESCRIPTOR imp;
; 38   :   PIMAGE_DOS_HEADER        dos;
; 39   :   PDWORD                   name;
; 40   :   PIMAGE_THUNK_DATA        oft, ft;
; 41   :   PIMAGE_IMPORT_BY_NAME    ibn;  
; 42   :   PIMAGE_NT_HEADERS        nt;
; 43   :   PIMAGE_DATA_DIRECTORY    dir;
; 44   :   LPVOID                   base, gpa=NULL;

	xor	edi, edi

; 45   :   PWCHAR                   dll;
; 46   :   PPEB                     peb;
; 47   :   PPEB_LDR_DATA            ldr;
; 48   :   PLDR_DATA_TABLE_ENTRY    dte;
; 49   :   
; 50   :   LoadLibrary("advapi32.dll"); // only for testing

	push	OFFSET ??_C@_0N@INAGJMNN@advapi32?4dll?$AA@
	mov	DWORD PTR _gpa$[ebp], edi
	call	DWORD PTR __imp__LoadLibraryA@4

; 51   :   
; 52   : #if defined(_WIN64)
; 53   :   peb = (PPEB) __readgsqword(0x60);
; 54   : #else
; 55   :   peb = (PPEB) __readfsdword(0x30);

	mov	eax, DWORD PTR fs:48

; 56   : #endif
; 57   : 
; 58   :   ldr = (PPEB_LDR_DATA)peb->Ldr;
; 59   :   
; 60   :   // for each DLL loaded
; 61   :   for (dte=(PLDR_DATA_TABLE_ENTRY)ldr->InLoadOrderModuleList.Flink;
; 62   :        dte->DllBase != NULL && gpa == NULL; 
; 63   :        dte=(PLDR_DATA_TABLE_ENTRY)dte->InLoadOrderLinks.Flink)

	mov	eax, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [eax+12]
	mov	eax, DWORD PTR [edx+24]
	cmp	eax, edi
	je	$LN15@main
	push	ebx
	push	esi
$LL33@main:
	cmp	DWORD PTR _gpa$[ebp], edi
	jne	$LN34@main

; 64   :   {
; 65   :     // hash the DLL
; 66   :     dll = dte->BaseDllName.Buffer;
; 67   : 
; 68   :     for (hash=0, i=0; i<dte->BaseDllName.Length/2; i++) {

	movzx	esi, WORD PTR [edx+44]
	shr	esi, 1
	mov	ecx, DWORD PTR [edx+48]
	mov	DWORD PTR _i$[ebp], edi
	je	$LN16@main
$LL14@main:

; 69   :       hash = ROTR32(hash, 13); 
; 70   :       hash += dll[i] | 0x20;  

	mov	ebx, DWORD PTR _i$[ebp]
	movzx	ebx, WORD PTR [ecx+ebx*2]
	or	ebx, 32					; 00000020H
	ror	edi, 13					; 0000000dH
	add	edi, ebx
	inc	DWORD PTR _i$[ebp]
	cmp	DWORD PTR _i$[ebp], esi
	jb	SHORT $LL14@main

; 71   :     }
; 72   :     
; 73   :     // is this our target DLL?
; 74   :     if (hash == DLL_HASH) 

	cmp	edi, 1120728991				; 42ccf79fH
	jne	SHORT $LN16@main

; 75   :     {      
; 76   :       base = dte->DllBase;
; 77   :       dos  = (PIMAGE_DOS_HEADER)base;
; 78   :       nt   = RVA2VA(PIMAGE_NT_HEADERS, base, dos->e_lfanew);
; 79   :       dir  = (PIMAGE_DATA_DIRECTORY)nt->OptionalHeader.DataDirectory;
; 80   :       rva  = dir[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;  
; 81   :       imp  = (PIMAGE_IMPORT_DESCRIPTOR) RVA2VA(ULONG_PTR, base, rva);

	mov	ecx, DWORD PTR [eax+60]
	mov	ecx, DWORD PTR [ecx+eax+128]
	add	ecx, eax

; 85   :       {
; 86   :         if (imp->Name==0) break;

	jmp	SHORT $LN37@main
$LL10@main:

; 87   :         name = RVA2VA(PDWORD, base, imp->Name);
; 88   :         
; 89   :         if ((name[0] | 0x20202020) == 'nrek' && 
; 90   :             (name[1] | 0x20202020) == '23le')

	mov	ebx, DWORD PTR [esi+eax]
	mov	edi, 538976288				; 20202020H
	or	ebx, edi
	cmp	ebx, 1852990827				; 6e72656bH
	jne	SHORT $LN9@main
	mov	esi, DWORD PTR [esi+eax+4]
	or	esi, edi
	cmp	esi, 842230885				; 32336c65H
	jne	SHORT $LN9@main

; 91   :         {
; 92   :           // locate GetProcAddress
; 93   :           rva = imp->OriginalFirstThunk;
; 94   :           oft = (PIMAGE_THUNK_DATA)RVA2VA(ULONG_PTR, base, rva);
; 95   :           
; 96   :           rva = imp->FirstThunk;
; 97   :           ft  = (PIMAGE_THUNK_DATA)RVA2VA(ULONG_PTR, base, rva);

	mov	esi, DWORD PTR [ecx+16]
	mov	edi, DWORD PTR [ecx]
	add	esi, eax
	add	edi, eax
	mov	DWORD PTR _ft$[ebp], esi

; 100  :           {
; 101  :             rva = oft->u1.AddressOfData;

	mov	esi, DWORD PTR [edi]

; 102  :             if (rva==0) break;

	test	esi, esi
	je	SHORT $LN9@main
	sub	edi, DWORD PTR _ft$[ebp]
	mov	ebx, DWORD PTR _ft$[ebp]
$LL5@main:

; 103  :             
; 104  :             ibn = (PIMAGE_IMPORT_BY_NAME)RVA2VA(ULONG_PTR, base, rva);
; 105  :             name = (PDWORD)ibn->Name;

	lea	esi, DWORD PTR [eax+esi+2]

; 106  :             
; 107  :             // is this GetProcAddress?
; 108  :             if (name[0] == 'PteG' && name[2] == 'erdd') {

	cmp	DWORD PTR [esi], 1349805383		; 50746547H
	jne	SHORT $LN4@main
	cmp	DWORD PTR [esi+8], 1701995620		; 65726464H
	je	SHORT $LN25@main
$LN4@main:

; 98   :             
; 99   :           for (;; oft++, ft++) 

	add	ebx, 4

; 100  :           {
; 101  :             rva = oft->u1.AddressOfData;

	mov	esi, DWORD PTR [edi+ebx]

; 102  :             if (rva==0) break;

	test	esi, esi
	jne	SHORT $LL5@main
	jmp	SHORT $LN9@main
$LN25@main:

; 109  :               gpa = (LPVOID)ft->u1.Function;

	mov	esi, DWORD PTR [ebx]
	mov	DWORD PTR _gpa$[ebp], esi
$LN9@main:

; 82   :   
; 83   :       // locate kernel32.dll
; 84   :       for (;;imp++) 

	add	ecx, 20					; 00000014H
$LN37@main:

; 85   :       {
; 86   :         if (imp->Name==0) break;

	mov	esi, DWORD PTR [ecx+12]
	test	esi, esi
	jne	SHORT $LL10@main
$LN16@main:

; 56   : #endif
; 57   : 
; 58   :   ldr = (PPEB_LDR_DATA)peb->Ldr;
; 59   :   
; 60   :   // for each DLL loaded
; 61   :   for (dte=(PLDR_DATA_TABLE_ENTRY)ldr->InLoadOrderModuleList.Flink;
; 62   :        dte->DllBase != NULL && gpa == NULL; 
; 63   :        dte=(PLDR_DATA_TABLE_ENTRY)dte->InLoadOrderLinks.Flink)

	mov	edx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+24]
	xor	edi, edi
	cmp	eax, edi
	jne	$LL33@main
$LN34@main:
	pop	esi
	pop	ebx
$LN15@main:

; 110  :               break;
; 111  :             }
; 112  :           }
; 113  :         }
; 114  :       }
; 115  :     }
; 116  :   }    
; 117  :   printf ("\nGetProcAddress : %p\n", gpa);

	push	DWORD PTR _gpa$[ebp]
	push	OFFSET ??_C@_0BG@NJBDAAND@?6GetProcAddress?5?3?5?$CFp?6?$AA@
	call	_printf
	pop	ecx
	pop	ecx

; 118  :   return 0;

	xor	eax, eax
	pop	edi

; 119  : }

	leave
	ret	0
_main	ENDP
_TEXT	ENDS
END
