; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	c:\hub\shellcode\win\getapi\module\extern_gpa.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_ms
; Function compile flags: /Ogspy
; File c:\hub\shellcode\win\getapi\module\extern_gpa.c
;	COMDAT _ms
_TEXT	SEGMENT
_s$ = 8							; size = 4
_ms	PROC						; COMDAT

; 36   :   DWORD hash;
; 37   :   
; 38   :   for (hash=0; *s; s++) {

	mov	edx, DWORD PTR _s$[esp-4]
	xor	eax, eax
	jmp	SHORT $LN9@ms
$LL3@ms:

; 39   :     hash = ROTR32(hash, 13); 
; 40   :     hash += *s | 0x20;  

	movsx	ecx, cl
	or	ecx, 32					; 00000020H
	ror	eax, 13					; 0000000dH
	add	eax, ecx
	inc	edx
$LN9@ms:

; 36   :   DWORD hash;
; 37   :   
; 38   :   for (hash=0; *s; s++) {

	mov	cl, BYTE PTR [edx]
	test	cl, cl
	jne	SHORT $LL3@ms

; 41   :   }
; 42   :   return hash;
; 43   : }

	ret	0
_ms	ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@NJBDAAND@?6GetProcAddress?5?3?5?$CFp?6?$AA@ ; `string'
PUBLIC	??_C@_09GBJOOODB@?6found?5it?$AA@		; `string'
PUBLIC	??_C@_0M@FHOJOPDB@?6?$CF08lX?5?9?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_03KALPDNHK@?6?$CFp?$AA@			; `string'
PUBLIC	_main
EXTRN	_printf:PROC
EXTRN	__imp__GetProcAddress@8:PROC
;	COMDAT ??_C@_0BG@NJBDAAND@?6GetProcAddress?5?3?5?$CFp?6?$AA@
CONST	SEGMENT
??_C@_0BG@NJBDAAND@?6GetProcAddress?5?3?5?$CFp?6?$AA@ DB 0aH, 'GetProcAdd'
	DB	'ress : %p', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09GBJOOODB@?6found?5it?$AA@
CONST	SEGMENT
??_C@_09GBJOOODB@?6found?5it?$AA@ DB 0aH, 'found it', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FHOJOPDB@?6?$CF08lX?5?9?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0M@FHOJOPDB@?6?$CF08lX?5?9?5?$CFs?$AA@ DB 0aH, '%08lX - %s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03KALPDNHK@?6?$CFp?$AA@
CONST	SEGMENT
??_C@_03KALPDNHK@?6?$CFp?$AA@ DB 0aH, '%p', 00H		; `string'
; Function compile flags: /Ogspy
CONST	ENDS
;	COMDAT _main
_TEXT	SEGMENT
_dte$ = -12						; size = 4
_gpa$ = -8						; size = 4
_hash$ = -4						; size = 4
_main	PROC						; COMDAT

; 46   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi

; 47   :   DWORD                    rva, hash;
; 48   :   PIMAGE_IMPORT_DESCRIPTOR imp;
; 49   :   PIMAGE_DOS_HEADER        dos;
; 50   :   PDWORD                   name;
; 51   :   PIMAGE_THUNK_DATA        oft, ft;
; 52   :   PIMAGE_IMPORT_BY_NAME    ibn;  
; 53   :   PIMAGE_NT_HEADERS        nt;
; 54   :   PIMAGE_DATA_DIRECTORY    dir;
; 55   :   LPVOID                   base, gpa=NULL;

	xor	edi, edi

; 56   :   PCHAR                    dll;
; 57   :   PPEB                     peb;
; 58   :   PPEB_LDR_DATA            ldr;
; 59   :   PLDR_DATA_TABLE_ENTRY    dte;
; 60   :   
; 61   :   // only here so the API is part of import table
; 62   :   GetProcAddress(0, 0);

	push	edi
	push	edi
	mov	DWORD PTR _gpa$[ebp], edi
	call	DWORD PTR __imp__GetProcAddress@8

; 63   :   //printf ("\n%08lX", ms("kernel32.dll"));
; 64   :   
; 65   : #if defined(_WIN64)
; 66   :   peb = (PPEB) __readgsqword(0x60);
; 67   : #else
; 68   :   peb = (PPEB) __readfsdword(0x30);

	mov	eax, DWORD PTR fs:48

; 69   : #endif
; 70   : 
; 71   :   ldr = (PPEB_LDR_DATA)peb->Ldr;
; 72   :   dte=(PLDR_DATA_TABLE_ENTRY)ldr->InLoadOrderModuleList.Flink;

	mov	eax, DWORD PTR [eax+12]
	mov	ebx, DWORD PTR [eax+12]

; 73   :   
; 74   :   printf ("\n%p", dte->DllBase);

	push	DWORD PTR [ebx+24]
	mov	DWORD PTR _dte$[ebp], ebx
	push	OFFSET ??_C@_03KALPDNHK@?6?$CFp?$AA@
	call	_printf

; 75   :   
; 76   :   // for each DLL loaded
; 77   :   for (;dte->DllBase != NULL && gpa != NULL; 
; 78   :        dte=(PLDR_DATA_TABLE_ENTRY)dte->InLoadOrderLinks.Flink)

	mov	esi, DWORD PTR [ebx+24]
	pop	ecx
	pop	ecx
	cmp	esi, edi
	je	$LN14@main
$LL30@main:
	cmp	DWORD PTR _gpa$[ebp], 0
	je	$LN14@main

; 79   :   {
; 80   :     base = dte->DllBase;
; 81   :     dos  = (PIMAGE_DOS_HEADER)base;
; 82   :     nt   = RVA2VA(PIMAGE_NT_HEADERS, base, dos->e_lfanew);
; 83   :     dir  = (PIMAGE_DATA_DIRECTORY)nt->OptionalHeader.DataDirectory;
; 84   :     rva  = dir[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;  
; 85   :     imp  = (PIMAGE_IMPORT_DESCRIPTOR) RVA2VA(ULONG_PTR, base, rva);

	mov	eax, DWORD PTR [esi+60]
	mov	edi, DWORD PTR [eax+esi+128]
	add	edi, esi

; 89   :     {
; 90   :       rva = imp->Name;

	jmp	$LN32@main
$LL13@main:

; 92   :         break;
; 93   :       }
; 94   :       dll = RVA2VA(PCHAR, base, rva);
; 95   :       
; 96   :       for (hash=0; *dll; dll++) {

	and	DWORD PTR _hash$[ebp], 0
	lea	edx, DWORD PTR [eax+esi]
	mov	ecx, edx
	mov	al, BYTE PTR [ecx]
	test	al, al
	je	SHORT $LN7@main
$LL9@main:

; 97   :         hash = ROTR32(hash, 13); 

	mov	ebx, DWORD PTR _hash$[ebp]

; 98   :         hash += *dll | 0x20;  

	movsx	eax, al
	or	eax, 32					; 00000020H
	ror	ebx, 13					; 0000000dH
	add	ebx, eax
	inc	ecx
	mov	al, BYTE PTR [ecx]
	mov	DWORD PTR _hash$[ebp], ebx
	test	al, al
	jne	SHORT $LL9@main

; 92   :         break;
; 93   :       }
; 94   :       dll = RVA2VA(PCHAR, base, rva);
; 95   :       
; 96   :       for (hash=0; *dll; dll++) {

	mov	ebx, DWORD PTR _dte$[ebp]
$LN7@main:

; 99   :       }
; 100  :        printf ("\n%08lX - %s", hash, RVA2VA(PCHAR, base, rva));

	push	edx
	push	DWORD PTR _hash$[ebp]
	push	OFFSET ??_C@_0M@FHOJOPDB@?6?$CF08lX?5?9?5?$CFs?$AA@
	call	_printf
	add	esp, 12					; 0000000cH

; 101  :        
; 102  :       // is this the DLL we need?      
; 103  :       if (hash == DLL_HASH) 

	cmp	DWORD PTR _hash$[ebp], -1880304065	; 8fecd63fH
	jne	SHORT $LN12@main

; 104  :       {    
; 105  :         printf ("\nfound it");

	push	OFFSET ??_C@_09GBJOOODB@?6found?5it?$AA@
	call	_printf

; 106  :         // locate GetProcAddress
; 107  :         rva = imp->OriginalFirstThunk;
; 108  :         oft = (PIMAGE_THUNK_DATA)RVA2VA(ULONG_PTR, base, rva);

	mov	edx, DWORD PTR [edi]
	add	edx, esi

; 114  :         {
; 115  :           rva = oft->u1.AddressOfData;

	mov	eax, DWORD PTR [edx]
	pop	ecx
	mov	ecx, DWORD PTR [edi+16]
	add	ecx, esi

; 116  :           if (rva==0) break;

	test	eax, eax
	je	SHORT $LN12@main
	sub	edx, ecx
$LL5@main:

; 117  :           
; 118  :           ibn = (PIMAGE_IMPORT_BY_NAME)RVA2VA(ULONG_PTR, base, rva);
; 119  :           name = (PDWORD)ibn->Name;

	lea	eax, DWORD PTR [esi+eax+2]

; 120  :           
; 121  :           // is this GetProcAddress?
; 122  :           if (name[0] == 'PteG' && name[2] == 'erdd') {

	cmp	DWORD PTR [eax], 1349805383		; 50746547H
	jne	SHORT $LN4@main
	cmp	DWORD PTR [eax+8], 1701995620		; 65726464H
	je	SHORT $LN25@main
$LN4@main:

; 109  :         
; 110  :         rva = imp->FirstThunk;
; 111  :         ft  = (PIMAGE_THUNK_DATA)RVA2VA(ULONG_PTR, base, rva);
; 112  :           
; 113  :         for (;; oft++, ft++) 

	add	ecx, 4

; 114  :         {
; 115  :           rva = oft->u1.AddressOfData;

	mov	eax, DWORD PTR [edx+ecx]

; 116  :           if (rva==0) break;

	test	eax, eax
	jne	SHORT $LL5@main
	jmp	SHORT $LN12@main
$LN25@main:

; 123  :             gpa = (LPVOID)ft->u1.Function;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR _gpa$[ebp], eax
$LN12@main:

; 86   :   
; 87   :     // locate the dll by hash
; 88   :     for (;;imp++) 

	add	edi, 20					; 00000014H
$LN32@main:

; 89   :     {
; 90   :       rva = imp->Name;

	mov	eax, DWORD PTR [edi+12]

; 91   :       if (rva==0) {

	test	eax, eax
	jne	$LL13@main

; 75   :   
; 76   :   // for each DLL loaded
; 77   :   for (;dte->DllBase != NULL && gpa != NULL; 
; 78   :        dte=(PLDR_DATA_TABLE_ENTRY)dte->InLoadOrderLinks.Flink)

	mov	ebx, DWORD PTR [ebx]
	mov	esi, DWORD PTR [ebx+24]
	mov	DWORD PTR _dte$[ebp], ebx
	test	esi, esi
	jne	$LL30@main
$LN14@main:

; 124  :             break;
; 125  :           }
; 126  :         }
; 127  :       }
; 128  :     }
; 129  :   }  
; 130  :   printf ("\nGetProcAddress : %p\n", gpa);

	push	DWORD PTR _gpa$[ebp]
	push	OFFSET ??_C@_0BG@NJBDAAND@?6GetProcAddress?5?3?5?$CFp?6?$AA@
	call	_printf
	pop	ecx
	pop	ecx
	pop	edi
	pop	esi

; 131  :   return 0;

	xor	eax, eax
	pop	ebx

; 132  : }

	leave
	ret	0
_main	ENDP
_TEXT	ENDS
END
